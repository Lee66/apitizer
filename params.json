{"name":"APItizer","tagline":"API mocking for the client side JavaScript applications","body":"# APItizer\r\n\r\nAPItizer is a library that allows you to mock APIs for browser applications with JSON schema. JSON schema is usually used to validate responses from APIs, but APItizer adds the ability to generate data from the same structure.\r\n\r\nAPItizer requires understanding of the JSON schema syntax and I can recommend [this guide](http://spacetelescope.github.io/understanding-json-schema/) to get you started.\r\n\r\n## Why\r\n\r\nWhen developing single page apps, it is beneficial to develop frontend and backend in parallel. To achieve that, you need to mock the API. APItizer allows you to mock your API by defining the JSON schema which is used to generate the fake data.\r\n\r\nPrevious to the version `0.1.0` APItizer was using the [can.fixture](http://canjs.com/docs/can.fixture.html) library to mock the XHR requests, but it was replaced with the [FakeXMLHttpRequest](https://github.com/trek/FakeXMLHttpRequest) library. FakeXMLHttpRequest library replaces the browser XHR object which ensures that APItizer can be used without any other library (jQuery or Zepto).\r\n\r\nThis change requires you to manually start the APItizer from your code with the following command:\r\n\r\n\tapitizer.start();\r\n\r\nThis will replace the `window.XMLHttpRequest` object and allow APItizer to take over. Stopping APItizer is done with the following command:\r\n\r\n\tapitizer.stop();\r\n\r\n## Installation\r\n\r\nInstall it with bower:\r\n    \r\n    bower install apitizer\r\n\r\nAPItizer can used included either as a script tag:\r\n\r\n\t<script type=\"text/javascript\" src=\"path/to/apitizer.js\"></script>\r\n\r\nOr loaded with the Require.js (or any other AMD loader):\r\n\r\n\tdefine([\"path/to/apitizer\"], function(apitizer){ })\r\n\r\nAfter the APItizer is loaded you have to start it before it can intercept the requests:\r\n\t\r\n\tdefine([\"path/to/apitizer\"], function(apitizer){ \r\n\t\tapitizer.start();\r\n\t})\r\n\r\n\r\n## Example\r\n\r\nLet's implement a simple user endpoint. It will reside on the `/users` endpoint and implement all the usual `REST` operations.\r\n\r\nFirst let's define the schema:\r\n\r\n\tvar schema = {\r\n\t\ttype : \"object\",\r\n\t\tproperties : {\r\n\t\t\tid : {\r\n\t\t\t\ttype : \"integer\"\r\n\t\t\t},\r\n\t\t\tusername : {\r\n\t\t\t\ttype : \"string\"\r\n\t\t\t},\r\n\t\t\tpassword : {\r\n\t\t\t\ttype : \"string\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\nNow we can add it to the APItizer:\r\n\r\n\tapitizer.addSchema('user', schema);\r\n\r\nAfter adding it to the `apitizer` we can mock the API:\r\n\r\n\tapitizer.fixture.resource('/users', apitizer.schemaStore('user', 10));\r\n\r\nThis will create a store with 10 users in it and add all REST API endpoints:\r\n\r\n\tGET /users\r\n\tGET /users/{id}\r\n\tPOST /users\r\n\tPUT /users/{id}\r\n\tDELETE /users/{id}\r\n\r\nNow you can normally use AJAX functions and they will hit the mocked API:\r\n\r\n\t$.get('/users') // Response will return 10 users\r\n\t$.get('/users/1') // Response will return the user with the id 1\r\n\t$.post('/users', {username : 'foo', password : 'bar'}) // User will be created and saved to the store\r\n\t$.ajax('/users/1', {type : 'put', data : {username : 'baz'}}) // User with the id 1 will be updated\r\n\t$.ajax('/users/1', {type : 'delete'}) // User with the id 1 will be destroyed and removed from the store\r\n\r\n## Overriding generators\r\n\r\nAPItizer implements it's own generators for all types supported by the JSON schema, but sometimes you want more control over the data that is being generated. To achieve this, you can pass overrides to the store:\r\n\r\n\tvar store = apitizer.schemaStore('user', 10, {\r\n\t\tid : apitizer.types.autoincrement(),\r\n\t\tusername : function(){\r\n\t\t\tvar count = 1;\r\n\t\t\treturn function(){\r\n\t\t\t\treturn \"User \" + (count++);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\nThis store will now contain objects that look like this:\r\n\r\n\t[{\r\n\t\tid: 1,\r\n\t\tusername : \"User 1\",\r\n\t\tpassword : ...\r\n\t},\r\n\t{\r\n\t\tid: 2,\r\n\t\tusername : \"User 2\",\r\n\t\tpassword : ...\r\n\t}]\r\n\r\nUsing overrides will allow you to take control over parts of your data that are important to you. Another use for the overrides is embedding an object from one store to the object generated from another store. \r\n\r\nLet's say you want to mock a simple publishing API, where you have two types of resources:\r\n\r\n1. Articles\r\n2. Authors\r\n\r\nEach article contains the author object. You can easilly write a schema for this:\r\n\r\n\tvar authorSchema = {\r\n\t\ttype : \"object\",\r\n\t\tproperties : {\r\n\t\t\tid : {\r\n\t\t\t\ttype : \"integer\"\r\n\t\t\t},\r\n\t\t\tusername : {\r\n\t\t\t\ttype : \"string\"\r\n\t\t\t},\r\n\t\t\tpassword : {\r\n\t\t\t\ttype : \"string\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar articleSchema = {\r\n\t\ttype : \"object\",\r\n\t\tproperties : {\r\n\t\t\ttitle : {\r\n\t\t\t\ttype : \"string\"\r\n\t\t\t},\r\n\t\t\tbody : {\r\n\t\t\t\ttype : \"string\"\r\n\t\t\t},\r\n\t\t\tauthor : {\r\n\t\t\t\t$ref : \"author\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tapitizer.addSchema('author', authorSchema);\r\n\tapitizer.addSchema('article', articleSchema);\r\n\r\n_This example introduces another concept, referenced schemas which are denoted by the `$ref` key. For now, it is enough to know that this will get the `author` schema from the repository and use it to generate the data._\r\n\r\nIf we create `author` and `article` stores without overrides:\r\n\r\n\tvar authorStore = apitizer.schemaStore('author', 10);\r\n\tvar articleStore = apitizer.schemaStore('article', 10);\r\n\r\nEach article will contain generated `author` object, but that author object will not look like anything contained in the `authorStore`. We can fix that by using overrides:\r\n\r\n\tvar authorStore = apitizer.schemaStore('author', 10);\r\n\tvar articleStore = apitizer.schemaStore('article', 10, {\r\n\t\tauthor : authorStore.one()\r\n\t});\r\n\r\nIn this case `authorStore.one()` will return a random object from the store, and that object will be embedded in the `author` property of the `article`.\r\n\r\n\r\n## Custom data and API endpoints\r\n\r\nIn some cases you might need additional API points that can handle some specific task. For instance you might have `/login` endpoint where users can login. This action will still use the `users` store, but will have to behave differently than the default REST actions. Also, for development and testing you need a user with the known credentials, so you can actually login to the app. Here is how you can solve this problem with APItizer:\r\n\r\n\tvar schema = {\r\n\t\ttype : \"object\",\r\n\t\tproperties : {\r\n\t\t\tid : {\r\n\t\t\t\ttype : \"integer\"\r\n\t\t\t},\r\n\t\t\tusername : {\r\n\t\t\t\ttype : \"string\"\r\n\t\t\t},\r\n\t\t\tpassword : {\r\n\t\t\t\ttype : \"string\"\r\n\t\t\t}\r\n\t\t}\r\n\t}, userStore;\r\n\r\n\tapitizer.addSchema('user', schema);\r\n\tuserStore = apitizer.schemaStore('user', 0, {\r\n\t\tid : apitizer.types.autoincrement()\r\n\t})\r\n\r\nHere we have defined the schema, and created an empty store, now we can add some custom data:\r\n\r\n\tuserStore.add({\r\n\t\tusername : 'retro',\r\n\t\tpassword : '1337'\r\n\t});\r\n\r\nThis will create a user with known credentials. Now all we need to do is create the `/login` endpoint:\r\n\r\n\tapitizer.fixture('POST /login', function(params){\r\n\t\tvar users = userStore.db(params) // Search the data in the store's database\r\n\t\tif(users.count() === 0){\r\n\t\t\tthrow {errors: ['Wrong credentials'], status: 401}\r\n\t\t} else {\r\n\t\t\treturn users.first();\r\n\t\t}\r\n\t});\r\n\r\n_APItizer uses the excellent [TaffyDB](http://www.taffydb.com) library to store the data, so you can use it's [fancy querying possibilities](http://www.taffydb.com/workingwithdata) to get the data._\r\n\r\nNow you can emulate the login process by POSTing to the `/login` endpoint:\r\n\r\n\t$.post('/login', {\r\n\t\tusername : 'retro',\r\n\t\tpassword : 1338\r\n\t}).then(function(user){\r\n\t\talert('You logged in!')\r\n\t}, function(error){\r\n\t\talert('Wrong credentials!')\r\n\t});\r\n\r\n## Response delay\r\n\r\nTo simulate the real requests, responses will be returned with a delay. Default delay is 200 milliseconds, but you can easiliy change it:\r\n\r\n\tapitizer.fixture.delay(300) // delay is now 300 milliseconds\r\n\r\nYou can also give it a range of values, which will make the delay random:\r\n\r\n\tapitizer.fixture.delay(200, 500) // delay will be between 200 and 500 milliseconds\r\n\r\nRandom delay is a good way to simulate the real network conditions, and to get a feeling of responsivnes of your app.\r\n\r\n--\r\n\r\nYou can find more docs in the [wiki](https://github.com/retro/apitizer/wiki)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}